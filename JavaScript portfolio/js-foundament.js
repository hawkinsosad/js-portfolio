База для роботи HTML І JS.
document - за рахунок цього об'єкту ви можете звертатись до усієї html структури вашого сайту.
getElementById = шукає елемент по його айді.
getElementsByTagName = шукає зразу групу елементів за певним тегом, наприклад - span.
getElementsByClassName = шукає групу елементів з певним класом
addEventListener - додаткова функція, зачасту використовується з getElementbyId, додає любу подію до якогось айді, наприклад
document.getElementbyId('myform').addEventListener('submit', checkForm) - обов'вязково прописуємо checkForm без лапок, бо якщо записати це в них, подія виконається зразу ж, а це нам не потрібно,
також сюда можна додати що, щоб не оновлювалась сторінк при натискані, потрібно дописати в дужки: function(e) {
	e.preventDefault();
}};

Якщо потрібно щоб при натискані на кнопку, перекидувало на інше посилання регестрації або кудись ще, потрібно указати
window.location = ''

Якщо потрібно відслідкувати подію відправки данних в формі, то краще це вставити в саму форму: <form onsumbit="checkForm"> 

'usestrict' - прописується на початку кода, щоб самий код виповнювався тільки В СТРОГОМУ РЕЖИМІ

<noscript> використовується тоді, коли браузер не підтримує мову JS, наприклад:
    <noscipt>  JS not working </noscipt>

<script> призначений для написання фукнціоналу (скріптів) для сайта (можуть бути декілька їх)
Зазвичай його пишуть в кінці body, header, footer-кодах бо це НЕ ПЕРЕШКОДЖАЄ іншим елементам коду.
функція write дозволяє щось виписати на екран, (обов'язково в кінці ";").
Скрипт спрацьовує саме в тому місці, де він був прописанний.


Якщо прописати ! на початкі зміної то це буде = false, наприклад:
if(isJohnCar = true) = true
if(!isJohnCar) = false

Також якщо прописати наприклад: let name = 1;
	name == 2; - true
	name === 2;  - false (3 знака дорівнює означає що дія хибна)


===========Типи даних=========
String

    Представляет текстовую информацию
    Хранится как последовательность 16-битных неотрицательных целых чисел, представляющих кодовые единицы UTF-16
    Неизменяемый тип данных
    Используется для хранения строковых значений

Number

    Представляет числовые значения с плавающей точкой
    Использует 64-битное двоичное формат IEEE 754
    Может хранить числа от -2^53 до 2^53-1 без потери точности
    Для больших чисел может использоваться BigInt

BigInt

    Представляет целые числа произвольной величины
    Создается добавлением суффикса 'n' к числу или вызовом функции BigInt()
    Позволяет безопасно хранить и выполнять операции с большими целыми числами

Boolean

    Представляет логическое значение
    Может принимать только два значения: true или false
    Используется для условных выражений и проверок

Null

    Представляет отсутствие объектного значения
    Единственное значение этого типа - null
    Используется для обозначения отсутствующего объекта

Undefined

    Означает отсутствие значения для переменной
    Единственное значение этого типа - undefined
    Используется когда переменная объявлена, но не инициализирована

Object

    Самый гибкий тип данных в JavaScript
    Может содержать свойства и методы
    Является изменяемым типом данных
    Используется для создания сложных структур данных

Ключевые отличия:

    String, Number, BigInt - примитивные типы данных
    Boolean, Null, Undefined - также примитивные типы
    Object - собственный тип данных
    Null и Undefined - специальные значения, а не типы данных
    BigInt введен в ES2020 для работы с очень большими целыми числами

	
	
============Косноль=============
    

console - виводить всю інформацію в КОНСОЛЬ браузера, а не на його сторінку
функція .log та info - дозволяє написати щось в консолі.
функція .error - виводить повідолмення у форматі "помилки" (червона оконтовка)
функція .warn - виводить повідомлення у форматі "увага" (жовта оконтовка)
Не забуваємо використовувати підтег "src", щоб можна було перенаправити на файл скріпту, і не засоряти основний файл хтмл. Наприклад:
    <script src="index.js"></script>  
Якщо треба об'єднати якусь функцію, то потрібно використовути "+", наприклад: console.log("Result:" + num);
    
==================Зміні====================
    
Зміні - ви їх можете уявляти як певні ячейки пам'яті компю'тера, куди ми можемо заносити інформацію і далі з нею взаємодіяти. Ми можемо робити багато різних функцій з ними.
    var або let - зміна, називаємо її як завгодно, окрім спеціальних символів.

var = num;
num = 5; тобто, зміна (var) з назвою num має значення (=) 5.
Можна все писати разом, var num = 5;

const - константа, значення якої не можна змінити.

Буловий тип даних як true або false;

var isJohnCar = true;

const - майже те саме що і let, але таку змінну нельзя буде змінити якщо ми будемо її виводить
	
Якщо писати текст в лапках, то це буде саме текст, як наприклад цитати, тому можна використовувати це як, наприклад:
var num = "10";
Це не результат, це просто текст як називається зміна.

Нижче наведено декілька існуючих типів даних у мові JavaScript:

    var some = 1 Integer - цілі числа;
    var some = 1.12 Float - числа с плаваючою точкою;
    var some = "Привіт" String - текст;
    var some = true Boolean - приймають лише true або false.

============Математичні дії==============

У JavaScript можна виконувати всі математичні операції. Це такі операції, як:

    віднімання - z = y - x;
    додаванян - z = y + x;
    множення - z = y * x;
    ділення - z = y / x (на нуль ділити не можна);
    залишок при діленні - z = y % x;

Якщо операція проходить над однією і тією ж змінною, можна запис скоротити:

z = z + 20;
z += 20; // Цей запис аналогічний тому, що знаходиться вище

var num1 = 52;
var num2 = 12;

var res = num1-num2;
console.log("Result: " + res); - Потрібно все записувати ось так,бо так буде зрозуміло. Записуємо спочатку зміни з числами, а потім создаємо ще одну зміну, тільки ОКРЕМО для результата. На виході у нас получається: Зміна результат = Зміна1-Зміна2.
Або ось так:

console.log("Result: " + (num1 + num2));
console.log("Result: " + (num1 * num2));
console.log("Result: " + (num1 / num2));
console.log("Result: " + (num1 - num2));

    
    
Якщо необхідно збільшити чи зменшити число на 1, ми можемо прописати ++ і -- відповідно:

var z = 10;
z += 1;
z++; // Аналогічно тому, що прописано вище

Клас Math

JavaScript має великий функціонал для роботи з математичними операціями. Для них передбачено спеціальний клас Math.

var pi = Math.PI;
console.log(pi);

функція min та max - дозволяє знайти мінімальне та максимальне число серед наданих.
var pi = Math.PI;
Console.log(math.min(1,-2,-5,6));

===========Умовні оператори============
У JavaScript if та else — це конструкції, які використовуються для умовних перевірок. Вони допомагають комп'ютеру вирішувати, яку частину коду виконати залежно від того, чи виконується певна умова.
Що таке if?

if — це оператор, який перевіряє, чи виконується умова. Якщо умова істинна (правдива), то код всередині блоку if виконується.

let a = 10;

if (a > 5) {
  console.log("a більше 5");
}

У цьому прикладі умова a > 5 перевіряється. Оскільки a дорівнює 10, умова істинна, і тому виводиться повідомлення "a більше 5".
Що таке else?

else використовується разом із if. Якщо умова в if не виконалась (тобто вона була хибною), тоді виконується код всередині блоку else.

Приклад:

let a = 3;

if (a > 5) {
  console.log("a більше 5");
} else {
  console.log("a менше або дорівнює 5");
}

У цьому випадку умова a > 5 хибна (бо 3 не більше 5), тому виконується код з блоку else, і виводиться повідомлення "a менше або дорівнює 5".
Як це використовується?

Умови if та else використовуються, коли потрібно зробити рішення в коді на основі якихось перевірок. Наприклад:

    Перевірка на правильність введених даних (чи пароль вірний, чи правильний формат email).
    Визначення, чи потрібно виконати певну дію в залежності від обставин (наприклад, якщо температура більше 30°C, вивести повідомлення про жарку погоду).

else if використовується, коли потрібно перевірити кілька умов одна за одною. Це розширення конструкції if-else, яке дозволяє додати ще одну або більше умов для перевірки, якщо попередня умова не виконалась.
Як працює else if?

Якщо умова в if не виконалася (була хибною), то програма перевіряє наступну умову в блоці else if. І так далі, поки одна з умов не виявиться істинною або не буде досягнуто останнього блоку else.
Приклад використання else if:

let temperature = 25;

if (temperature > 30) {
  console.log("Спека!");
} else if (temperature > 20) {
  console.log("Тепла погода");
} else if (temperature > 10) {
  console.log("Прохолодно");
} else {
  console.log("Холодно");
}

У цьому прикладі ми перевіряємо кілька умов:

    Якщо температура більше 30 градусів, виведеться "Спека!".
    Якщо температура не більше 30, але більше 20, виведеться "Тепла погода".
    Якщо температура не більше 20, але більше 10, виведеться "Прохолодно".
    Якщо жодна з умов не виконалась (тобто температура менше або дорівнює 10), виведеться "Холодно".

Пояснення:

    Спочатку перевіряється умова в if (температура > 30). Якщо вона істинна, виконуватиметься перший блок коду.
    Якщо умова в if не виконалась, то програма переходить до першого else if і перевіряє, чи температура більше 20. Якщо так, виконується цей блок.
    Якщо жодна з умов у if або else if не виконалась, виконуватиметься блок else (у нашому випадку, виведеться "Холодно").


Ще якщо потрібно перевірити декілька умов, потрібно використовувати амперсанти (&&):
    var num =15;
    var IsHasCar = true;
    if(num >= 10 && num !IsHasCar);
    console.log("Yes");
    console.log("Yes, he has a car");

Як працює switch?

switch перевіряє вираз і порівнює його значення з варіантами, вказаними в кожному з case. 
    Якщо значення виразу збігається з одним з варіантів, виконується відповідний блок коду. Якщо жоден варіант не підходить, можна використовувати блок default, який виконується в разі відсутності збігів.

вираз — це значення, яке ви хочете перевірити.
case значення — це можливі значення, які ви порівнюєте з виразом.
break — припиняє виконання конструкції switch після того, як був знайдений і виконаний відповідний блок коду. Якщо break не використовується, то код продовжить виконуватися і після наступного case.
default — це блок, який виконується, якщо жоден з варіантів не підходить.
    
let day = 3;

switch (day) {
  case 1:
    console.log("Понеділок");
    break;
  case 2:
    console.log("Вівторок");
    break;
  case 3:
    console.log("Середа");
    break;
  case 4:
    console.log("Четвер");
    break;
  case 5:
    console.log("П'ятниця");
    break;
  case 6:
    console.log("Субота");
    break;
  case 7:
    console.log("Неділя");
    break;
  default:
    console.log("Невірний номер дня");
}
У цьому прикладі змінна day має значення 3. Конструкція switch перевіряє це значення і виконує блок коду під case 3, тому виводиться "Середа".
Пояснення:

    Якщо значення змінної day дорівнює 3, буде виконаний код під case 3 і виведеться "Середа".
    Якщо значення не відповідає жодному з варіантів, виконується блок default, який виводить "Невірний номер дня".

Переваги використання switch:

    Легкість читання: Якщо є багато можливих варіантів для перевірки, switch дозволяє зберегти код чистим і зрозумілим.
    Менше вкладених умов: У порівнянні з багатьма if-else if, switch дозволяє не вкладати умови одна в одну, а просто перерахувати їх.

Коли використовувати switch?

switch найкраще використовувати, коли вам потрібно перевірити одну змінну на кілька конкретних значень.
    Замість того, щоб використовувати кілька if-else if умов, ви можете перерахувати всі варіанти в switch. Це зручно, якщо можливих варіантів багато, і ви хочете, щоб код був компактним і легко читаним.

==========Масиви даних============
Певні зміни, де ми можемо зберігати декілька різних значень, до яких ми можемо звертатись.
    let data = new Array(1, 2, 3, 4, 5); - масив 
Можна ще записувати так: let data = []
    В любий момент коли знадобиться, можна звернутись до масива.
  data = [5, 6, 2, 3]
Якщо потрібно вивести в консоль будь який елемент ПЕРШИМ, потрібно зробити наступне:
    console.log(data [0]); - в такому випадку цифра "5" буде першою, бо ми прописали 0. Якщо прописати наприклад (data [3]) то у нас на масиві первим елементом буде 3.
ЗАВЖДИ ПОТРІБНО ЗВЕРТАТИСЬ НА ОДИНИЦЮ МЕНЬШЕ ІНДЕКСА, БО РАХУНОК ЙДЕ З НУЛЯ (0).

Функція length - використовується в консолі з data, вказує скільки елементів масиву є в ньому (1, 2, 3, 4, 5) - 5.

Масив matrix - згрупований масив даних, які може вміщати в себе багато інших масивів, наприклад:
    let matrix = [[1, 2], [true, "no"] [false, 0.5]]; - тобто ми бачимо на перший взгляд звичайний масив, але тут коли ми будемо звертатись до нього, то ми будемо звертатись не тільки до елементів, а і до масивів в середині нього:
matrix[0] - звертаємось  до першого масива (1, 2).
matrix[0] [0] - звертаємось до першого масива і першого елемента, тобто до 1. 

=======Цикли========
    Цикли — це конструкції в програмуванні, які дозволяють повторювати блок коду кілька разів, що дуже зручно, коли потрібно виконувати однотипні дії. Розглянемо три основні типи циклів: for, while і do while.
Цикл for
Цикл for використовують, коли ми точно знаємо, скільки разів потрібно виконати дію. Його стандартний вигляд:


Приклад:

for (int i = 0; i < 5; i++) {
    System.out.println(i);
}

    ініціалізація: задає початкове значення змінної (тут i = 0).
    умова: перевіряє, чи слід продовжувати цикл (тут i < 5).
    зміна: змінює значення змінної (тут i++ — збільшує i на 1).

Результат: програма виведе числа від 0 до 4. Кожного разу, коли i стає 5, цикл припиняється
        
Цикл while
Цикл while виконує блок коду, доки умова є істинною. Він підходить, коли не знаємо точну кількість повторень заздалегідь.

while (умова) {
    // код, який виконується в циклі
}

Приклад:

int i = 0;
while (i < 5) {
    System.out.println(i);
    i++;
}

    Спочатку перевіряється умова i < 5.
    Якщо вона істинна, виконується код всередині циклу.
    Після кожного виконання збільшуємо i на 1.

Результат: теж числа від 0 до 4, але формат дещо інший.
        
Цикл do while
Цикл do while працює схоже на while, але він гарантовано виконується хоча б один раз, навіть якщо умова спочатку хибна.

Приклад:

int i = 0;
do {
    System.out.println(i);
    i++;
} while (i < 5);

    Спочатку виконується блок коду.
    Потім перевіряється умова i < 5.

Результат: теж числа від 0 до 4.
Порівняння

    for: використовують, коли відомо, скільки разів потрібно виконати цикл.
    while: застосовують, коли не відомо точну кількість повторень, але відома умова для зупинки.
    do while: схожий на while, але з виключенням, що блок коду виконається хоча б раз.

======Оператори для циклів=======
1. Оператор break

break припиняє виконання циклу достроково, незалежно від того, чи виконана умова.
Приклад:

for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // цикл зупиниться, коли i дорівнюватиме 5
    }
    System.out.println(i);
}

Результат: виведе числа від 0 до 4, після чого цикл припиниться, коли i стане 5.
2. Оператор continue

continue пропускає поточну ітерацію циклу та переходить до наступної, залишаючи решту коду всередині циклу невиконаним для цієї ітерації.
Приклад:

for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue;  // пропустить 5 і перейде до наступної ітерації
    }
    System.out.println(i);
}

Результат: виведе числа від 0 до 9, але пропустить 5.

============Функціональні вікна===========
Функціональні вікна alert, prompt та confirm — це базові способи взаємодії з користувачем у браузері. Вони дозволяють виводити інформацію, отримувати дані чи підтвердження від користувача.

    1. alert

alert — це вікно, яке просто показує повідомлення. Користувач може лише натиснути OK.
Синтаксис:

alert("Ваше повідомлення");

Приклад:

alert("Привіт! Це інформаційне вікно.");

Результат: З'явиться вікно з текстом "Привіт! Це інформаційне вікно.", і кнопкою OK.
2. prompt

prompt — це вікно, яке дозволяє користувачеві ввести текст. Воно повертає введений текст або null, якщо користувач натиснув Cancel.
Синтаксис:

let result = prompt("Ваше запитання", "значення за замовчуванням");

    "Ваше запитання" — текст, який з'явиться у вікні.
    "значення за замовчуванням" (не обов'язково) — текст, який з'явиться у полі вводу.

Приклад:

let name = prompt("Як вас звати?", "Анонім");
if (name) {
    alert("Привіт, " + name + "!");
} else {
    alert("Ви не ввели своє ім'я.");
}

Результат:

    Якщо користувач введе своє ім'я, з'явиться вікно із привітанням: "Привіт, [ім'я]!".
    Якщо нічого не введе або натисне Cancel, з'явиться повідомлення: "Ви не ввели своє ім'я."

3. confirm

confirm — це вікно для підтвердження. Воно показує текст і дозволяє користувачеві вибрати OK (повертає true) або Cancel (повертає false).
Синтаксис:

let result = confirm("Ваше запитання?");

Приклад:

let isAdult = confirm("Вам є 18 років?");
if (isAdult) {
    alert("Доступ дозволено.");
} else {
    alert("Доступ заборонено.");
}

Результат:

    Якщо користувач натисне OK, з'явиться повідомлення: "Доступ дозволено."
    Якщо натисне Cancel, з'явиться повідомлення: "Доступ заборонено."

    Підсумок:

    alert: тільки показує повідомлення.
    prompt: запитує текст у користувача.
    confirm: дозволяє отримати підтвердження (так/ні).

========Функції у JS==========
Функції можна назвати невеликими підпрограмами, куди можна винести код, що повторюється, і звертатися до нього, коли це буде потрібно. 
    Функції значно полегшують побудову програм, оскільки нам не потрібно копіювати однотипний код багато разів, а можна просто скористатися однією загальною функцією.
Багато хто плутає функції та методи і не розуміє відмінностей між ними. Насправді відмінностей немає, бо що методи, що функції є одним і тим же. Функції записані поза класами називають функціями, а функції записані всередині класів називаються методами. 


Точно така ситуація зі змінним. У класах змінні називаються полями, а поза класами – змінними.
У JS функції створюються за допомогою ключового слова function. Кожна функція може мати будь-які параметри або не мати їх зовсім. Функції здатні щось повертати під час виконання коду, якщо це потрібно.

Створення функції
На основі всіх даних наша функція буде виглядати так:

function test() {
	console.log("Виведення чогось у консоль");
}

Ця функція не приймає жодних параметрів і нічого не повертає. Вона просто пише слово у консоль. Давайте урізноманітнимо функцію і додамо параметр:

function test(word) {
	console.log(word);
}

Тепер функція приймає параметр, який буде відображено у консолі.
Якщо функція має щось повернути, прописуємо тип даних який буде повернуто. Для повернення даних використовуємо ключове слово return:

function test(some_number) {
	some_number *= 2;
	return some_number;
}

Локальні та глобальні змінні
У JavaScript є кілька форматів видимості: локальна та глобальна. Якщо записати глобальну змінну, то таку змінну буде видно всюди і з нею можна працювати звідусіль у документі. Якщо записати локальну змінну, то таку змінну буде видно лише у тій області, де записана.
Для створення глобальної змінної її необхідно прописати поза функцією, класом або об'єктом. Для створення локальних змінних вам достатньо помістити змінну у функцію. Змінну функції буде видно лише всередині блоку з функцією і ніде більше.

return в JavaScript використовується для того, щоб передати значення з функції назад до місця її виклику. Це дозволяє використовувати результат роботи функції в іншій частині програми.
Як працює return?

    Завершує виконання функції. Код після return у функції більше не виконується.
    Повертає значення. Значення після return стає результатом виклику функції.

Приклади використання:
1. Простий приклад: повернення значення

function add(a, b) {
  return a + b; // Повертає суму a і b
}

let result = add(3, 5); // result = 8
console.log(result); // Виведе 8

2. Повернення об’єктів або масивів

function createUser(name, age) {
  return { name: name, age: age };
}

let user = createUser("Анна", 25);
console.log(user); // Виведе { name: "Анна", age: 25 }

3. Умовне використання return

function checkNumber(num) {
  if (num > 0) {
    return "Додатнє число";
  } else if (num < 0) {
    return "Від’ємне число";
  }
  return "Нуль";
}

console.log(checkNumber(5)); // Виведе "Додатнє число"
console.log(checkNumber(-3)); // Виведе "Від’ємне число"
console.log(checkNumber(0)); // Виведе "Нуль"

4. Використання для виходу з функції

function divide(a, b) {
  if (b === 0) {
    return "На нуль ділити не можна!"; // Завершує функцію, якщо b дорівнює 0
  }
  return a / b;
}

console.log(divide(10, 2)); // Виведе 5
console.log(divide(10, 0)); // Виведе "На нуль ділити не можна!"

Ключові моменти:

    Якщо у функції немає return, вона повертає undefined.

function noReturn() {
  console.log("Привіт!");
}
let result = noReturn(); // result = undefined

    return використовується для передачі значення в логіку програми, наприклад, у змінну, в іншу функцію чи в обчислення.

Де використовується?

    Для виконання обчислень і передачі результату.
    Для завершення функції достроково.
    У складних алгоритмах для побудови гнучких і динамічних функцій.

==========Події та обробник подій в JS===========
onclick="" - подія яка запускає скрипт коли ви натискаєте на умовну кнопку, або другий елемент
ondblclick="" - подія яка запускає скрипт коли ви ДВА РАЗИ натискаєте на умовну кнопку, або другий елемент
onmouseenter="" - подія яка запускає скрипт коли наводите мишку на кнопку, або другий елемент
onmouseleave="" - подія яка запускає скрипт коли ви прибираєте курсор з кнопки, або другого елементу
onmousemove="" - подія яка запускає скрипт коли ви тримаєте мишку на кнопкі, або другому елементі
onchange="" - подія яка запускає скрипт коли міняється значення СЕЛЕКТОРІВ
oninput="" - подія яка запускає скрипт коли ви вводете якісь данні в полі для вводу, або другий елемент



this - за допомогою цього елемента, ви можете певну вашу функцію передати тей об'єкт де виконується ваша подія.

    <button name='jopa' ondblclick="btnClick()" onclick="btnOnceClick(this)"> Натисни на мене</button> 

	  function btnClick() {
    alert('message');
}

function btnOnceClick(el) {                               - за допомогою цього ми зможемо замінити назву об'єкта, тобто на ПОЧАТКУ кнопкає має ім'я "jopa", але після того як ми прописуємо в подію onclick="btnOnceClick(THIS)",
    el.name = 'asdasdasd';                                а в function btnOnceClick ми прописуємо БУДЬ ЯКУ назву, то вони пов'язуються між собою і це дозволяє міняти назву і тд. 
    alert(el.name);
}

Простой счетчик:
	  
    <button onclick="btnOnceClick(this)"> Натисни на мене</button>
let counter = 0;

function btnOnceClick(el) {
    counter++;
    el.innerHTML = 'Count: ' + counter;
} 

========Таймери та інтервали========
За допомогою таймерів ми зможемо зробити код,який буде виконаний через певний проміжок часу.
Інтервал -  майже те саме, але він буде ПОСТІЙНО виконувати певний код, через певний проміжок часу.
setInterval(my_func, 1000); - функція + 1000 мс.

Альтернативний спосіб записувати інтервали:
setInterval(function() {
    console.log('sec');
}, 1000);
Таймер:
setTimeout(function() {
    alert('message'); 

}, 5000);
=========Створення різних об'єктів, додаткові функції==========
Щоб створити дату, наприклад цього року, нам потрібно створити зміну date, дати їй властивості new Date();
та вивести все це в в консоль: console.log(date.getFullYear()); -  це можна робити не тільки з роком.
Також з підфункцією setDate можна створити свою дату.
Створення масиву та його сортировка:
let arr = [9, 2, 5, 7, 'some', true];
console.log(arr.sort());
Масив в зворотньому напрямку: (arr.reverse()); - це можна комбінувати з сортировкою
==========split та join==========
split - використовується, тоді коли ви хочете розбити якийсь текст на масиви за допомогою, наприклад ",".
join - навпаки дозволяє соєдіняти якийсь текст.
=========this========
Использование ключевого слова this в JavaScript имеет несколько важных преимуществ:

    Динамическое контекстное поведение:
        this позволяет функциям и методам динамически ссылаться на текущий объект, независимо от того, как они вызываются.

    Улучшенная читаемость и поддерживаемость кода:
        Использование this делает код более декларативным и понятным, особенно при работе с объектами и методами.

    Гибкость в реализации:
        this позволяет создавать универсальные функции и методы, которые могут работать с разными объектами без изменения их самих.

    Уменьшение дублирования кода:
        При использовании this, можно определить один метод для нескольких объектов, а не копировать его для каждого отдельного случая.

    Соответствие принципам ООП:
        this помогает реализовать концепции классов и наследования в JavaScript.

    Возможность работы с прототипами:
        this позволяет легко работать с прототипами и наследованием в объектно-ориентированном стиле.

    Улучшение производительности:
        Использование this может привести к более эффективному выполнению кода за счет оптимизации вызовов методов и доступа к свойствам объекта.

Например, в следующем коде:

let obj = {
  name: "John",
  greet: function() {
    console.log(`Hello, I'm ${this.name}`);
  }
};

obj.greet(); // Выведет: Hello, I'm John

Использование this позволяет методу greet динамически ссылаться на свой объект, независимо от того, как он вызывается. Это делает код более гибким и удобным для использования с различными объектами.

Таким образом, хотя можно написать console.log('hello, i'm john'), использование this предоставляет больше возможностей для создания динамического и гибкого кода в JavaScript.

========Строки и их свойства=======
У строк есть свойства, с помощью которых вы можете получить доступ к элементам, например:
length - длина строки. "" - (строка с одним пробелом = 0), "  " - (строка с двумя пробелами = 1)
Благодаря этому, можно получить или обратиться к какому-то определенному символу, например:
const name = 'August'
console.log(name[0]); - в консоль выведится Символ "А".
Так же не обязательно прописывать номер послдней буквы, можно прописать следующее:
console.log ( name[name.length - 1) - мы обращаемся к имени, и отнимаем от всей длины 1) так и получается последний символ "t".

At - приминяется к строке, как к объекту. По сути тоже самое что и length, только удобнее, так как можно прописывать минусовые значения, например:
const name 'August'
console.log( name.at(0)) - выведится первый символ - А
console.log( name.at(0)) - выведится второй символ - u
console.log( name.at(-1)) - выведится последний символ t
console.log( name.at(-2)) - выведится предпоследний символ s
	Все символы, которые мы получаемся с индекса, можно ТОЛЬКО получить, но нельзя изменить.
	  
toLowerCase, toUpperCase = переводит регистр букв в нижнее или верхнее соотвественно.

========Методы массивов=======
Первый метод forEach, заменяет стандартный цикл через итерацию на более удобный, пример:
let letter = ['A', 'B', 'C', 'D', 'E', 'F'];
letter.forEach((letter, index, array) => {
    console.log(`По индексу ${index} находится элемент ${letter}`);
});

indexOf - используется чтобы проверить есть ли тот или инной элемент в таблице. Например:
lastIndexOf - тоже самое, но с конца
const prices = [100, 200, 300, 444, 500]

console.log(prices.indexOf(444)) - если элемента в таблице, массиве и тд. нету, то выведится: -1

findIndex - внутри этой функции, есть три подфункции с тремя элементами колбек (element, index, array) - вручную перебирает каждый из элементов массива и цикла.
Например:
console.log(
    users.findIndex((user) => user.name === 'Kira')
)

includes - проверяет наличие элемента в массиве, например:
Если какой-то элемент в массиве есть, то результат вернет как true.
const prices = [100,200,300,400,500];

console.log(prices.includes(500))

some -  в отличии от includes, тут мы можем проверять наличие более сложных структур, например найти объект.
Буквально проверяет, соответствует ли хотя бы 1 элемент массива заданным свойствам.
const users = [
    {
        name: 'August',
        age: '19',
    },
    {
        name: 'Kira',
        age: '17',
    },
]

console.log(
    users.some((user) => user.name === 'Kira') - выведится true,  так как у нас есть Кира.
)

every - проверяет каждый элемент на соответствие условия. Например с возрастом:
const users = [
    {
        name: 'August',
        age: '19',
    },
    {
        name: 'Kira',
        age: '17',
    },
]

console.log(
    users.every((user) => user.age >= 15) - выведится true, так как всем больше 15.
)
	  
Метод find просто позволяет найти какой-то элемент в массиве.

filter - если в массиве несколько элементов с одинаковым значением, то тут уже не подойдет find, так как он проверяет только первый.
const users = [
    {
        name: 'August',
        age: '19',
    },
    {
        name: 'Kira',
        age: '17',
    },
    {
        name: 'Kira',
        age: '19',
    },
    {
        name: 'Kira',
        age: '18',
    },
]

console.log(
    users.filter((user) => user.name === 'Kira') 
)
В консоли покажет:
Array(3) [ {…}, {…}, {…} ]
​
0: Object { name: "Kira", age: "17" }
​
1: Object { name: "Kira", age: "19" }
​
2: Object { name: "Kira", age: "18" }
​
length: 3

Еще один пример с filter, если нужно отфильтровать условных людей, по нескольким критериям, то можно сделать следующее:
const users = [
    {
        name: 'August',
        age: '19',
        city: 'Kyiv',
    },
    {
        name: 'Kira',
        age: '17',
        city: 'Zhytomyr',
    },
]

const filteredUsers = users.filter((user) => {
    return user.city === 'Kyiv' || user.age < 19
})

console.log(filteredUsers); 
Мы задаем условие, что выведутся только те, кто с города Киев, либо меньше 19 лет, то есть выведится следующее:
Array [ {…}, {…} ]
​
0: Object { name: "August", age: "19", city: "Kyiv" }
​
1: Object { name: "Kira", age: "17", city: "Zhytomyr" }
​
length: 2

map - позволяет перебрать исходный массив, и преобразовать/модифицировать изменить каждый из его элементов.
+он всегда возвращает новое значение, на основе массива, его копии
let users = [
    {
        name: 'August',
        age: '19',
        city: 'Kyiv',
    },
    {
        name: 'Kira',
        age: '17',
        city: 'Zhytomyr',
    },
]

users = users.map((user) => {
    return `${user.name}, ${user.age} лет, живёт в г. ${user.city}`
}) 

console.log(users)
в консоли:
let users = [
    {
        name: 'August',
        age: '19',
        city: 'Kyiv',
    },
    {
        name: 'Kira',
        age: '17',
        city: 'Zhytomyr',
    },
]

users = users.map((user) => {
    return `${user.name}, ${user.age} лет, живёт в г. ${user.city}`
}) 

console.log(users)
	    

Метод reduce в JavaScript используется для последовательной обработки элементов массива с целью вычисления какого-либо итогового значения (например, суммы, произведения или преобразования данных).
Вот пошаговое объяснение, как работает reduce:
Синтаксис

array.reduce(callback, initialValue)

    callback — функция, которая выполняется для каждого элемента массива. Она принимает четыре аргумента:
        accumulator — накопитель, который хранит результат обработки на каждом шаге.
        currentValue — текущий элемент массива.
        index (необязательно) — индекс текущего элемента.
        array (необязательно) — сам массив.
    initialValue — начальное значение для accumulator. Если его не указать, то первым значением будет первый элемент массива.

Пример с вашим кодом:

const users = [
    { name: 'August', age: 19, city: 'Kyiv' },
    { name: 'Kira', age: 17, city: 'Zhytomyr' },
];

const ageSum = users.reduce((sum, user) => {
    return sum + user.age;
}, 0);

    Начальное значение (initialValue):
    Указано 0. Это будет начальным значением для sum (накопителя).

    Первый элемент:
    Метод берёт первый объект в массиве: { name: 'August', age: 19, city: 'Kyiv' }.
        sum = 0 (начальное значение).
        user.age = 19.
        Возвращает: sum + user.age = 0 + 19 = 19.

    Второй элемент:
    Метод переходит ко второму объекту: { name: 'Kira', age: 17, city: 'Zhytomyr' }.
        sum = 19 (результат предыдущего шага).
        user.age = 17.
        Возвращает: sum + user.age = 19 + 17 = 36.

    Результат:
    После обработки всех элементов reduce возвращает итоговое значение: 36.

Конечный результат:

ageSum содержит сумму возрастов: 36.

Далее происходит деление:

console.log(
    "Average age of users: ",
    ageSum / users.length // 36 / 2 = 18
);

Итог:

Метод reduce позволяет обойти массив и вычислить какое-либо значение, накапливая результат. Он удобен для таких операций, как суммирование, нахождение максимума/минимума, объединение данных и других задач обработки массива.

В JavaScript цикл for...in, а также методы Object.keys, Object.values и Object.entries предназначены для работы с объектами. Давайте рассмотрим их по порядку:
Цикл for...in

Цикл for...in используется для перебора свойств объекта (его ключей).

Синтаксис:

for (let key in object) {
  // действия с ключом или значением
}

Пример:

const person = { name: "Alice", age: 25, city: "Paris" };

for (let key in person) {
  console.log(key); // Выводит ключи: "name", "age", "city"
  console.log(person[key]); // Выводит значения: "Alice", 25, "Paris"
}

    Важно:

        Этот цикл перебирает все перечисляемые свойства, включая унаследованные, если они не скрыты.
        Не рекомендуется использовать for...in для массивов, так как ключи (индексы) могут быть не в порядке.

Метод Object.keys()

Метод Object.keys возвращает массив, содержащий только ключи объекта.

Синтаксис:

Object.keys(object);

Пример:

const person = { name: "Alice", age: 25, city: "Paris" };

const keys = Object.keys(person);
console.log(keys); // ["name", "age", "city"]

Метод Object.values()

Метод Object.values возвращает массив, содержащий только значения объекта.

Синтаксис:

Object.values(object);

Пример:

const person = { name: "Alice", age: 25, city: "Paris" };

const values = Object.values(person);
console.log(values); // ["Alice", 25, "Paris"]

Метод Object.entries()

Метод Object.entries возвращает массив пар ключ-значение в виде вложенных массивов.

Синтаксис:

Object.entries(object);

Пример:

const person = { name: "Alice", age: 25, city: "Paris" };

const entries = Object.entries(person);
console.log(entries);
// [["name", "Alice"], ["age", 25], ["city", "Paris"]]

// Перебор с деструктуризацией
for (const [key, value] of entries) {
  console.log(`${key}: ${value}`);
}
// Вывод:
// name: Alice
// age: 25
// city: Paris

Метод Object.fromEntries() — это обратная операция к Object.entries(). Он принимает массив пар [ключ, значение] и возвращает объект, созданный на основе этих пар.
Синтаксис

Object.fromEntries(iterable);

    iterable — итерируемая структура данных (например, массив или Map), содержащая пары [ключ, значение].

Пример 1: Преобразование массива пар в объект

const entries = [["name", "Alice"], ["age", 25], ["city", "Paris"]];

const person = Object.fromEntries(entries);
console.log(person);
// { name: "Alice", age: 25, city: "Paris" }

Пример 2: Преобразование Map в объект

const map = new Map([
  ["name", "Bob"],
  ["age", 30],
  ["city", "Berlin"],
]);

const obj = Object.fromEntries(map);
console.log(obj);
// { name: "Bob", age: 30, city: "Berlin" }

Пример 3: Использование с Object.entries()

Методы Object.entries() и Object.fromEntries() можно комбинировать для преобразования объекта, например, при фильтрации:

const person = { name: "Alice", age: 25, city: "Paris" };

// Фильтруем только ключи, содержащие строку "name"
const filteredEntries = Object.entries(person).filter(([key, value]) => key.includes("name"));

const filteredObject = Object.fromEntries(filteredEntries);
console.log(filteredObject);
// { name: "Alice" }

Когда использовать Object.fromEntries()?

    Когда нужно преобразовать массив пар [ключ, значение] обратно в объект.
    Когда данные приходят в виде списка пар (например, из Map или другого источника).
    При работе с объектами, где нужно выполнить фильтрацию, сортировку или преобразование ключей/значений через массив.

	    
1. Set и его методы

Set — это коллекция уникальных значений, где значения не могут повторяться.
Методы Set:
Метод	Описание
set.add(value)	Добавляет значение в коллекцию.
set.has(value)	Проверяет, существует ли значение в коллекции. Возвращает true или false.
set.delete(value)	Удаляет значение из коллекции. Возвращает true, если элемент был удалён.
set.clear()	Удаляет все элементы из коллекции.
set.size	Возвращает количество элементов в коллекции.
Пример работы с Set:

const mySet = new Set();

// Добавляем значения
mySet.add(1);
mySet.add(2);
mySet.add(2); // Игнорируется, так как `Set` не допускает дубликатов

console.log(mySet.has(1)); // true
console.log(mySet.has(3)); // false

console.log(mySet.size); // 2

mySet.delete(1);
console.log(mySet.has(1)); // false

mySet.clear();
console.log(mySet.size); // 0

2. Map и его методы

Map — это коллекция, где ключи могут быть любого типа, и каждому ключу соответствует одно значение.
Методы Map:
Метод	Описание
map.set(key, value)	Устанавливает пару ключ-значение.
map.get(key)	Возвращает значение по ключу или undefined, если ключ не найден.
map.has(key)	Проверяет, существует ли ключ в коллекции. Возвращает true или false.
map.delete(key)	Удаляет ключ с соответствующим значением. Возвращает true, если ключ был удалён.
map.clear()	Удаляет все элементы из коллекции.
map.size	Возвращает количество элементов в коллекции.
Пример работы с Map:

const myMap = new Map();

// Устанавливаем пары ключ-значение
myMap.set("name", "Alice");
myMap.set("age", 25);

console.log(myMap.get("name")); // "Alice"
console.log(myMap.has("age")); // true
console.log(myMap.size); // 2

myMap.delete("age");
console.log(myMap.has("age")); // false

myMap.clear();
console.log(myMap.size); // 0

Эти методы используются для работы с коллекциями, такими как Set и Map в JavaScript. Давайте рассмотрим их по порядку.
1. Set и его методы

Set — это коллекция уникальных значений, где значения не могут повторяться.
Методы Set:
Метод	Описание
set.add(value)	Добавляет значение в коллекцию.
set.has(value)	Проверяет, существует ли значение в коллекции. Возвращает true или false.
set.delete(value)	Удаляет значение из коллекции. Возвращает true, если элемент был удалён.
set.clear()	Удаляет все элементы из коллекции.
set.size	Возвращает количество элементов в коллекции.
Пример работы с Set:

const mySet = new Set();

// Добавляем значения
mySet.add(1);
mySet.add(2);
mySet.add(2); // Игнорируется, так как `Set` не допускает дубликатов

console.log(mySet.has(1)); // true
console.log(mySet.has(3)); // false

console.log(mySet.size); // 2

mySet.delete(1);
console.log(mySet.has(1)); // false

mySet.clear();
console.log(mySet.size); // 0

2. Map и его методы

Map — это коллекция, где ключи могут быть любого типа, и каждому ключу соответствует одно значение.
Методы Map:
Метод	Описание
map.set(key, value)	Устанавливает пару ключ-значение.
map.get(key)	Возвращает значение по ключу или undefined, если ключ не найден.
map.has(key)	Проверяет, существует ли ключ в коллекции. Возвращает true или false.
map.delete(key)	Удаляет ключ с соответствующим значением. Возвращает true, если ключ был удалён.
map.clear()	Удаляет все элементы из коллекции.
map.size	Возвращает количество элементов в коллекции.
Пример работы с Map:

const myMap = new Map();

// Устанавливаем пары ключ-значение
myMap.set("name", "Alice");
myMap.set("age", 25);

console.log(myMap.get("name")); // "Alice"
console.log(myMap.has("age")); // true
console.log(myMap.size); // 2

myMap.delete("age");
console.log(myMap.has("age")); // false

myMap.clear();
console.log(myMap.size); // 0

Сравнение Set и Map:
Функциональность	Set	Map
Хранение значений	Только уникальные значения.	Пары ключ-значение.
Доступ к элементу	Через метод has(value).	Через метод get(key).
Добавление элементов	Метод add(value).	Метод set(key, value).
Удаление элемента	Метод delete(value).	Метод delete(key).
Очистка коллекции	Метод clear().	Метод clear().
Размер коллекции	Свойство size.	Свойство size.
Итог

    Используйте Set, если нужно работать с уникальными значениями.
    Используйте Map, если вам нужны пары ключ-значение.
